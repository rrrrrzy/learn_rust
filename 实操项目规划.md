# Rust å­¦ä¹ å®æ“é¡¹ç›®è§„åˆ’

## é¡¹ç›®è®¾è®¡ç†å¿µ

æœ¬å®æ“é¡¹ç›®è§„åˆ’åŸºäº**æ¸è¿›å¼å­¦ä¹ **å’Œ**å®è·µé©±åŠ¨**çš„æ•™å­¦ç†å¿µï¼Œæ¯ä¸ªé¡¹ç›®éƒ½ç²¾å¿ƒè®¾è®¡æ¥å·©å›ºç‰¹å®šçš„çŸ¥è¯†ç‚¹ï¼Œè®©å­¦ä¹ è€…é€šè¿‡åŠ¨æ‰‹å®è·µçœŸæ­£æŒæ¡ Rust ç¼–ç¨‹æŠ€èƒ½ã€‚

### è®¾è®¡åŸåˆ™
1. **çŸ¥è¯†ç‚¹è¦†ç›–**ï¼šæ¯ä¸ªé¡¹ç›®éƒ½å¯¹åº”ç‰¹å®šçš„æ•™ç¨‹ç« èŠ‚ï¼Œç¡®ä¿ç†è®ºä¸å®è·µç»“åˆ
2. **éš¾åº¦é€’è¿›**ï¼šä»ç®€å•çš„æ§åˆ¶å°ç¨‹åºåˆ°å¤æ‚çš„ç³»ç»Ÿåº”ç”¨
3. **å®ç”¨æ€§å¯¼å‘**ï¼šé¡¹ç›®å…·æœ‰å®é™…åº”ç”¨ä»·å€¼ï¼Œä¸æ˜¯ç®€å•çš„ç»ƒä¹ é¢˜
4. **å¯æ‰©å±•æ€§**ï¼šæ¯ä¸ªé¡¹ç›®éƒ½å¯ä»¥è¿›ä¸€æ­¥æ‰©å±•å’Œæ”¹è¿›

---

## é˜¶æ®µä¸€ï¼šåŸºç¡€è¯­æ³•å·©å›º (ç¬¬ 1-4 ç« )
*å­¦ä¹ å†…å®¹ï¼šå˜é‡ã€æ•°æ®ç±»å‹ã€å‡½æ•°ã€æ§åˆ¶æµ*

### é¡¹ç›® 1ï¼šæ™ºèƒ½è®¡ç®—å™¨
**å¯¹åº”ç« èŠ‚**ï¼š01-02 (å˜é‡å’Œæ•°æ®ç±»å‹)
**é¡¹ç›®æè¿°**ï¼šåˆ›å»ºä¸€ä¸ªæ”¯æŒåŸºæœ¬å››åˆ™è¿ç®—çš„è®¡ç®—å™¨

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡å˜é‡å£°æ˜å’Œå¯å˜æ€§
- ç†è§£ä¸åŒæ•°å€¼ç±»å‹çš„ä½¿ç”¨åœºæ™¯
- ç»ƒä¹ ç±»å‹è½¬æ¢å’Œç±»å‹å®‰å…¨

**åŠŸèƒ½è¦æ±‚**ï¼š
- æ”¯æŒæ•´æ•°å’Œæµ®ç‚¹æ•°è¿ç®—
- å¤„ç†é™¤é›¶é”™è¯¯
- æ”¯æŒè¿ç»­è®¡ç®—ï¼ˆç»“æœä½œä¸ºä¸‹æ¬¡è®¡ç®—çš„è¾“å…¥ï¼‰
- ä½¿ç”¨ä¸åŒçš„æ•°å€¼ç±»å‹å±•ç¤ºç±»å‹ç³»ç»Ÿ

**æŠ€æœ¯è¦ç‚¹**ï¼š
```rust
// ç¤ºä¾‹æ ¸å¿ƒä»£ç ç»“æ„
fn main() {
    let mut result: f64 = 0.0;
    let mut continue_calculation = true;
    
    while continue_calculation {
        // è·å–ç”¨æˆ·è¾“å…¥
        // è§£ææ“ä½œç¬¦å’Œæ“ä½œæ•°
        // æ‰§è¡Œè®¡ç®—å¹¶æ›´æ–°ç»“æœ
        // å¤„ç†é”™è¯¯æƒ…å†µ
    }
}
```

**æ‰©å±•æ€è·¯**ï¼š
- æ·»åŠ ç§‘å­¦è®¡ç®—åŠŸèƒ½ï¼ˆå¹³æ–¹æ ¹ã€å¹‚è¿ç®—ï¼‰
- æ”¯æŒæ‹¬å·è¿ç®—
- æ·»åŠ å†å²è®°å½•åŠŸèƒ½

---

### é¡¹ç›® 2ï¼šæ–‡æœ¬åˆ†æå·¥å…·
**å¯¹åº”ç« èŠ‚**ï¼š03-04 (å‡½æ•°å’Œæ§åˆ¶æµ)
**é¡¹ç›®æè¿°**ï¼šåˆ†ææ–‡æœ¬æ–‡ä»¶æˆ–ç”¨æˆ·è¾“å…¥çš„ç»Ÿè®¡ä¿¡æ¯

**å­¦ä¹ ç›®æ ‡**ï¼š
- ç»ƒä¹ å‡½æ•°çš„å®šä¹‰å’Œè°ƒç”¨
- æŒæ¡æ§åˆ¶æµç»“æ„ï¼ˆif/elseã€loopã€matchï¼‰
- ç†è§£ä½œç”¨åŸŸå’Œæ‰€æœ‰æƒåŸºç¡€æ¦‚å¿µ

**åŠŸèƒ½è¦æ±‚**ï¼š
- ç»Ÿè®¡å­—ç¬¦æ•°ã€å•è¯æ•°ã€è¡Œæ•°
- åˆ†æå­—ç¬¦é¢‘ç‡
- æŸ¥æ‰¾æœ€é•¿/æœ€çŸ­å•è¯
- ä½¿ç”¨ä¸åŒçš„æ§åˆ¶æµç»“æ„

**æŠ€æœ¯è¦ç‚¹**ï¼š
```rust
fn analyze_text(text: &str) -> TextStats {
    let mut stats = TextStats::new();
    
    for line in text.lines() {
        stats.line_count += 1;
        
        for word in line.split_whitespace() {
            stats.word_count += 1;
            
            for ch in word.chars() {
                stats.char_count += 1;
                // ä½¿ç”¨ match å¤„ç†ä¸åŒå­—ç¬¦ç±»å‹
            }
        }
    }
    
    stats
}
```

**æ‰©å±•æ€è·¯**ï¼š
- æ”¯æŒå¤šç§æ–‡ä»¶æ ¼å¼
- æ·»åŠ æƒ…æ„Ÿåˆ†æ
- å®ç°å…³é”®è¯é«˜é¢‘ç»Ÿè®¡

---

## é˜¶æ®µäºŒï¼šæ‰€æœ‰æƒç³»ç»ŸæŒæ¡ (ç¬¬ 5-6 ç« )
*å­¦ä¹ å†…å®¹ï¼šæ‰€æœ‰æƒã€å€Ÿç”¨ã€å¼•ç”¨ã€åˆ‡ç‰‡*

### é¡¹ç›® 3ï¼šå†…å­˜å®‰å…¨çš„å­—ç¬¦ä¸²å¤„ç†å™¨
**å¯¹åº”ç« èŠ‚**ï¼š05-06 (æ‰€æœ‰æƒå’Œå¼•ç”¨)
**é¡¹ç›®æè¿°**ï¼šå®ç°ä¸€ä¸ªå¼ºè°ƒå†…å­˜å®‰å…¨çš„å­—ç¬¦ä¸²å¤„ç†åº“

**å­¦ä¹ ç›®æ ‡**ï¼š
- æ·±å…¥ç†è§£æ‰€æœ‰æƒè½¬ç§»è§„åˆ™
- æŒæ¡å€Ÿç”¨å’Œå¼•ç”¨çš„ä½¿ç”¨
- ç»ƒä¹ åˆ‡ç‰‡æ“ä½œ

**åŠŸèƒ½è¦æ±‚**ï¼š
- å­—ç¬¦ä¸²åè½¬ã€å¤§å°å†™è½¬æ¢
- å•è¯æå–å’Œæ›¿æ¢
- å®‰å…¨çš„å­—ç¬¦ä¸²åˆ‡ç‰‡æ“ä½œ
- å­—ç¬¦ä¸²æ‹¼æ¥å’Œåˆ†å‰²

**æŠ€æœ¯è¦ç‚¹**ï¼š
```rust
// æ¼”ç¤ºæ‰€æœ‰æƒè½¬ç§»
fn process_string(s: String) -> String {
    // s çš„æ‰€æœ‰æƒè¢«è½¬ç§»åˆ°è¿™é‡Œ
    s.to_uppercase()
} // s åœ¨è¿™é‡Œè¢«é‡Šæ”¾

// æ¼”ç¤ºå€Ÿç”¨
fn analyze_string(s: &str) -> (usize, usize) {
    (s.len(), s.chars().count())
}

// æ¼”ç¤ºå¯å˜å€Ÿç”¨
fn modify_string(s: &mut String) {
    s.push_str(" - processed");
}
```

**æ‰©å±•æ€è·¯**ï¼š
- å®ç°è‡ªå®šä¹‰å­—ç¬¦ä¸²ç±»å‹
- æ·»åŠ  Unicode å¤„ç†
- å®ç°å­—ç¬¦ä¸²æ± ä¼˜åŒ–

---

## é˜¶æ®µä¸‰ï¼šæ•°æ®ç»“æ„è®¾è®¡ (ç¬¬ 7-9 ç« )
*å­¦ä¹ å†…å®¹ï¼šç»“æ„ä½“ã€æšä¸¾ã€é›†åˆ*

### é¡¹ç›® 4ï¼šå­¦ç”Ÿæˆç»©ç®¡ç†ç³»ç»Ÿ
**å¯¹åº”ç« èŠ‚**ï¼š07-08 (ç»“æ„ä½“å’Œæšä¸¾)
**é¡¹ç›®æè¿°**ï¼šè®¾è®¡ä¸€ä¸ªå®Œæ•´çš„å­¦ç”Ÿä¿¡æ¯å’Œæˆç»©ç®¡ç†ç³»ç»Ÿ

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡ç»“æ„ä½“çš„å®šä¹‰å’Œæ–¹æ³•å®ç°
- ç†è§£æšä¸¾çš„å¼ºå¤§åŠŸèƒ½å’Œæ¨¡å¼åŒ¹é…
- ç»ƒä¹ å¤æ‚æ•°æ®ç»“æ„çš„è®¾è®¡

**åŠŸèƒ½è¦æ±‚**ï¼š
- å­¦ç”Ÿä¿¡æ¯ç®¡ç†ï¼ˆå¢åˆ æ”¹æŸ¥ï¼‰
- å¤šç§‘ç›®æˆç»©è®°å½•
- æˆç»©ç»Ÿè®¡å’Œæ’å
- ä¸åŒæˆç»©ç­‰çº§çš„æšä¸¾å¤„ç†

**æŠ€æœ¯è¦ç‚¹**ï¼š
```rust
#[derive(Debug, Clone)]
struct Student {
    id: u32,
    name: String,
    grade: Grade,
    subjects: HashMap<Subject, Score>,
}

#[derive(Debug, Clone)]
enum Grade {
    Freshman,
    Sophomore,
    Junior,
    Senior,
}

#[derive(Debug, Clone)]
enum ScoreLevel {
    Excellent(f64),    // 90-100
    Good(f64),         // 80-89
    Average(f64),      // 70-79
    Poor(f64),         // 60-69
    Fail(f64),         // 0-59
}

impl Student {
    fn calculate_gpa(&self) -> f64 {
        // å®ç° GPA è®¡ç®—
    }
    
    fn get_score_level(&self, subject: &Subject) -> Option<ScoreLevel> {
        // ä½¿ç”¨æ¨¡å¼åŒ¹é…è¿”å›æˆç»©ç­‰çº§
    }
}
```

**æ‰©å±•æ€è·¯**ï¼š
- æ·»åŠ æ•°æ®æŒä¹…åŒ–
- å®ç°æˆç»©è¶‹åŠ¿åˆ†æ
- æ·»åŠ å›¾å½¢åŒ–ç•Œé¢

---

### é¡¹ç›® 5ï¼šå›¾ä¹¦é¦†ç®¡ç†ç³»ç»Ÿ
**å¯¹åº”ç« èŠ‚**ï¼š09 (é›†åˆç±»å‹)
**é¡¹ç›®æè¿°**ï¼šä½¿ç”¨å„ç§é›†åˆç±»å‹æ„å»ºå›¾ä¹¦é¦†ç®¡ç†ç³»ç»Ÿ

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡ Vecã€HashMapã€HashSet çš„ä½¿ç”¨
- ç†è§£ä¸åŒé›†åˆç±»å‹çš„é€‚ç”¨åœºæ™¯
- ç»ƒä¹ å¤æ‚æ•°æ®æŸ¥è¯¢å’Œæ“ä½œ

**åŠŸèƒ½è¦æ±‚**ï¼š
- å›¾ä¹¦ä¿¡æ¯ç®¡ç†
- å€Ÿé˜…è®°å½•è¿½è¸ª
- è¯»è€…ä¿¡æ¯ç®¡ç†
- å›¾ä¹¦æœç´¢å’Œæ¨è

**æŠ€æœ¯è¦ç‚¹**ï¼š
```rust
use std::collections::{HashMap, HashSet, VecDeque};

struct Library {
    books: HashMap<String, Book>,           // ISBN -> Book
    readers: HashMap<u32, Reader>,          // ID -> Reader
    borrowed_books: HashMap<String, u32>,   // ISBN -> Reader ID
    waiting_queue: VecDeque<(String, u32)>, // (ISBN, Reader ID)
    categories: HashSet<String>,            // å›¾ä¹¦åˆ†ç±»
}

impl Library {
    fn search_books(&self, keyword: &str) -> Vec<&Book> {
        self.books.values()
            .filter(|book| {
                book.title.contains(keyword) || 
                book.author.contains(keyword) ||
                book.isbn.contains(keyword)
            })
            .collect()
    }
    
    fn recommend_books(&self, reader_id: u32) -> Vec<&Book> {
        // åŸºäºå€Ÿé˜…å†å²çš„æ¨èç®—æ³•
    }
}
```

**æ‰©å±•æ€è·¯**ï¼š
- å®ç°å¤æ‚çš„æœç´¢ç®—æ³•
- æ·»åŠ å›¾ä¹¦é¢„çº¦ç³»ç»Ÿ
- å®ç°æ•°æ®ç»Ÿè®¡å’ŒæŠ¥è¡¨

---

## é˜¶æ®µå››ï¼šæ¨¡å—åŒ–å¼€å‘ (ç¬¬ 10-11 ç« )
*å­¦ä¹ å†…å®¹ï¼šæ¨¡å—ç³»ç»Ÿã€é”™è¯¯å¤„ç†*

### é¡¹ç›® 6ï¼šæ–‡ä»¶å¤„ç†å·¥å…·ç®±
**å¯¹åº”ç« èŠ‚**ï¼š10-11 (æ¨¡å—ç³»ç»Ÿå’Œé”™è¯¯å¤„ç†)
**é¡¹ç›®æè¿°**ï¼šåˆ›å»ºä¸€ä¸ªæ¨¡å—åŒ–çš„æ–‡ä»¶å¤„ç†å·¥å…·é›†

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡æ¨¡å—ç³»ç»Ÿçš„è®¾è®¡å’Œä½¿ç”¨
- ç†è§£é”™è¯¯å¤„ç†çš„æœ€ä½³å®è·µ
- ç»ƒä¹  Result å’Œ Option çš„ä½¿ç”¨

**é¡¹ç›®ç»“æ„**ï¼š
```
file_tools/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ file_ops/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ reader.rs
â”‚   â”‚   â”œâ”€â”€ writer.rs
â”‚   â”‚   â””â”€â”€ analyzer.rs
â”‚   â”œâ”€â”€ crypto/
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â”œâ”€â”€ hash.rs
â”‚   â”‚   â””â”€â”€ encrypt.rs
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ mod.rs
â”‚       â”œâ”€â”€ path.rs
â”‚       â””â”€â”€ error.rs
â””â”€â”€ Cargo.toml
```

**åŠŸèƒ½è¦æ±‚**ï¼š
- æ–‡ä»¶è¯»å†™æ“ä½œ
- æ–‡ä»¶åŠ å¯†è§£å¯†
- æ–‡ä»¶å®Œæ•´æ€§éªŒè¯
- æ‰¹é‡æ–‡ä»¶å¤„ç†

**æŠ€æœ¯è¦ç‚¹**ï¼š
```rust
// src/utils/error.rs
#[derive(Debug)]
pub enum FileToolError {
    IoError(std::io::Error),
    PermissionDenied,
    FileNotFound(String),
    InvalidFormat(String),
}

impl From<std::io::Error> for FileToolError {
    fn from(error: std::io::Error) -> Self {
        FileToolError::IoError(error)
    }
}

// src/file_ops/reader.rs
pub fn read_file_safe(path: &Path) -> Result<String, FileToolError> {
    if !path.exists() {
        return Err(FileToolError::FileNotFound(
            path.display().to_string()
        ));
    }
    
    std::fs::read_to_string(path)
        .map_err(FileToolError::from)
}
```

**æ‰©å±•æ€è·¯**ï¼š
- æ·»åŠ ç½‘ç»œæ–‡ä»¶æ“ä½œ
- å®ç°æ–‡ä»¶åŒæ­¥åŠŸèƒ½
- æ·»åŠ GUIç•Œé¢

---

## é˜¶æ®µäº”ï¼šé«˜çº§ç‰¹æ€§åº”ç”¨ (ç¬¬ 12-14 ç« )
*å­¦ä¹ å†…å®¹ï¼šæ³›å‹ã€Traitã€ç”Ÿå‘½å‘¨æœŸ*

### é¡¹ç›® 7ï¼šé€šç”¨æ•°æ®å®¹å™¨åº“
**å¯¹åº”ç« èŠ‚**ï¼š12-13 (æ³›å‹å’ŒTrait)
**é¡¹ç›®æè¿°**ï¼šè®¾è®¡ä¸€ä¸ªé«˜åº¦å¯å¤ç”¨çš„æ•°æ®å®¹å™¨åº“

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡æ³›å‹çš„é«˜çº§åº”ç”¨
- ç†è§£ Trait çš„è®¾è®¡æ¨¡å¼
- ç»ƒä¹  Trait è¾¹ç•Œå’Œå…³è”ç±»å‹

**åŠŸèƒ½è¦æ±‚**ï¼š
- å®ç°å¤šç§å®¹å™¨ç±»å‹ï¼ˆæ ˆã€é˜Ÿåˆ—ã€æ ‘ï¼‰
- æ”¯æŒæ³›å‹å…ƒç´ ç±»å‹
- æä¾›ç»Ÿä¸€çš„å®¹å™¨æ¥å£
- å®ç°è¿­ä»£å™¨æ¨¡å¼

**æŠ€æœ¯è¦ç‚¹**ï¼š
```rust
// å®šä¹‰å®¹å™¨ trait
pub trait Container<T> {
    fn new() -> Self;
    fn len(&self) -> usize;
    fn is_empty(&self) -> bool;
    fn clear(&mut self);
}

pub trait Stack<T>: Container<T> {
    fn push(&mut self, item: T);
    fn pop(&mut self) -> Option<T>;
    fn peek(&self) -> Option<&T>;
}

pub trait Queue<T>: Container<T> {
    fn enqueue(&mut self, item: T);
    fn dequeue(&mut self) -> Option<T>;
    fn front(&self) -> Option<&T>;
}

// å®ç°é€šç”¨æ ˆ
pub struct VecStack<T> {
    items: Vec<T>,
}

impl<T> Container<T> for VecStack<T> {
    fn new() -> Self {
        VecStack { items: Vec::new() }
    }
    
    fn len(&self) -> usize {
        self.items.len()
    }
    
    fn is_empty(&self) -> bool {
        self.items.is_empty()
    }
    
    fn clear(&mut self) {
        self.items.clear()
    }
}

impl<T> Stack<T> for VecStack<T> {
    fn push(&mut self, item: T) {
        self.items.push(item);
    }
    
    fn pop(&mut self) -> Option<T> {
        self.items.pop()
    }
    
    fn peek(&self) -> Option<&T> {
        self.items.last()
    }
}
```

**æ‰©å±•æ€è·¯**ï¼š
- å®ç°çº¿ç¨‹å®‰å…¨ç‰ˆæœ¬
- æ·»åŠ æ€§èƒ½åŸºå‡†æµ‹è¯•
- å®ç°è‡ªå®šä¹‰è¿­ä»£å™¨

---

### é¡¹ç›® 8ï¼šå†…å­˜å®‰å…¨çš„ç¼“å­˜ç³»ç»Ÿ
**å¯¹åº”ç« èŠ‚**ï¼š14 (ç”Ÿå‘½å‘¨æœŸ)
**é¡¹ç›®æè¿°**ï¼šå®ç°ä¸€ä¸ªå¼ºè°ƒå†…å­˜å®‰å…¨çš„ç¼“å­˜ç³»ç»Ÿ

**å­¦ä¹ ç›®æ ‡**ï¼š
- æ·±å…¥ç†è§£ç”Ÿå‘½å‘¨æœŸæ¦‚å¿µ
- æŒæ¡ç”Ÿå‘½å‘¨æœŸæ³¨è§£çš„ä½¿ç”¨
- ç»ƒä¹ å¤æ‚çš„å¼•ç”¨å…³ç³»ç®¡ç†

**åŠŸèƒ½è¦æ±‚**ï¼š
- LRU ç¼“å­˜å®ç°
- è¿‡æœŸæ—¶é—´ç®¡ç†
- å†…å­˜ä½¿ç”¨é™åˆ¶
- çº¿ç¨‹å®‰å…¨æ”¯æŒ

**æŠ€æœ¯è¦ç‚¹**ï¼š
```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

pub struct Cache<'a, K, V> 
where 
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    data: HashMap<K, CacheEntry<'a, V>>,
    max_size: usize,
    default_ttl: Duration,
}

struct CacheEntry<'a, V> {
    value: V,
    created_at: Instant,
    ttl: Duration,
    access_count: u64,
    references: Vec<&'a V>, // æ¼”ç¤ºå¤æ‚ç”Ÿå‘½å‘¨æœŸå…³ç³»
}

impl<'a, K, V> Cache<'a, K, V> 
where 
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    pub fn new(max_size: usize, default_ttl: Duration) -> Self {
        Cache {
            data: HashMap::new(),
            max_size,
            default_ttl,
        }
    }
    
    pub fn get(&'a mut self, key: &K) -> Option<&'a V> {
        if let Some(entry) = self.data.get_mut(key) {
            if entry.is_expired() {
                self.data.remove(key);
                None
            } else {
                entry.access_count += 1;
                Some(&entry.value)
            }
        } else {
            None
        }
    }
    
    pub fn insert(&mut self, key: K, value: V) -> Result<(), CacheError> {
        if self.data.len() >= self.max_size {
            self.evict_lru()?;
        }
        
        let entry = CacheEntry {
            value,
            created_at: Instant::now(),
            ttl: self.default_ttl,
            access_count: 1,
            references: Vec::new(),
        };
        
        self.data.insert(key, entry);
        Ok(())
    }
}
```

**æ‰©å±•æ€è·¯**ï¼š
- å®ç°åˆ†å¸ƒå¼ç¼“å­˜
- æ·»åŠ ç¼“å­˜é¢„çƒ­åŠŸèƒ½
- å®ç°ç¼“å­˜ç»Ÿè®¡å’Œç›‘æ§

---

## é˜¶æ®µå…­ï¼šç³»ç»Ÿç¼–ç¨‹åº”ç”¨ (ç¬¬ 15-16 ç« )
*å­¦ä¹ å†…å®¹ï¼šæ ‡å‡†åº“ã€å¼‚æ­¥ç¼–ç¨‹*

### é¡¹ç›® 9ï¼šç³»ç»Ÿç›‘æ§å·¥å…·
**å¯¹åº”ç« èŠ‚**ï¼š15 (æ ‡å‡†åº“)
**é¡¹ç›®æè¿°**ï¼šå¼€å‘ä¸€ä¸ªè·¨å¹³å°çš„ç³»ç»Ÿç›‘æ§å·¥å…·

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡æ ‡å‡†åº“çš„é«˜çº§åŠŸèƒ½
- å­¦ä¹ ç³»ç»Ÿç¼–ç¨‹æŠ€å·§
- ç»ƒä¹ å®ç¼–ç¨‹

**åŠŸèƒ½è¦æ±‚**ï¼š
- CPUã€å†…å­˜ã€ç£ç›˜ä½¿ç”¨ç‡ç›‘æ§
- è¿›ç¨‹ç®¡ç†å’Œç›‘æ§
- ç½‘ç»œè¿æ¥çŠ¶æ€
- ç³»ç»Ÿæ—¥å¿—åˆ†æ

**æŠ€æœ¯è¦ç‚¹**ï¼š
```rust
use std::process::Command;
use std::fs;
use std::time::{Duration, SystemTime};
use std::collections::VecDeque;

// è‡ªå®šä¹‰å®ç”¨äºç®€åŒ–ç³»ç»Ÿä¿¡æ¯è·å–
macro_rules! system_info {
    ($cmd:expr) => {
        Command::new("sh")
            .arg("-c")
            .arg($cmd)
            .output()
            .map(|output| String::from_utf8_lossy(&output.stdout).to_string())
            .unwrap_or_else(|_| "Unknown".to_string())
    };
}

#[derive(Debug, Clone)]
pub struct SystemSnapshot {
    timestamp: SystemTime,
    cpu_usage: f64,
    memory_usage: MemoryInfo,
    disk_usage: Vec<DiskInfo>,
    network_info: NetworkInfo,
}

impl SystemSnapshot {
    pub fn capture() -> Result<Self, SystemError> {
        Ok(SystemSnapshot {
            timestamp: SystemTime::now(),
            cpu_usage: Self::get_cpu_usage()?,
            memory_usage: Self::get_memory_info()?,
            disk_usage: Self::get_disk_info()?,
            network_info: Self::get_network_info()?,
        })
    }
    
    fn get_cpu_usage() -> Result<f64, SystemError> {
        // ä½¿ç”¨ /proc/stat æˆ–ç³»ç»Ÿå‘½ä»¤è·å–CPUä½¿ç”¨ç‡
        let output = system_info!("top -bn1 | grep 'Cpu(s)' | awk '{print $2}' | cut -d'%' -f1");
        output.trim().parse()
            .map_err(|_| SystemError::ParseError("CPU usage".to_string()))
    }
}

pub struct Monitor {
    snapshots: VecDeque<SystemSnapshot>,
    max_history: usize,
}

impl Monitor {
    pub fn new(max_history: usize) -> Self {
        Monitor {
            snapshots: VecDeque::new(),
            max_history,
        }
    }
    
    pub fn start_monitoring(&mut self, interval: Duration) -> Result<(), SystemError> {
        loop {
            let snapshot = SystemSnapshot::capture()?;
            
            if self.snapshots.len() >= self.max_history {
                self.snapshots.pop_front();
            }
            
            self.snapshots.push_back(snapshot);
            
            std::thread::sleep(interval);
        }
    }
}
```

**æ‰©å±•æ€è·¯**ï¼š
- æ·»åŠ æŠ¥è­¦åŠŸèƒ½
- å®ç°Webç•Œé¢
- æ”¯æŒè¿œç¨‹ç›‘æ§

---

### é¡¹ç›® 10ï¼šå¼‚æ­¥Webçˆ¬è™«
**å¯¹åº”ç« èŠ‚**ï¼š16 (å¼‚æ­¥ç¼–ç¨‹)
**é¡¹ç›®æè¿°**ï¼šæ„å»ºä¸€ä¸ªé«˜æ€§èƒ½çš„å¼‚æ­¥Webçˆ¬è™«ç³»ç»Ÿ

**å­¦ä¹ ç›®æ ‡**ï¼š
- æŒæ¡å¼‚æ­¥ç¼–ç¨‹æ¨¡å‹
- ç†è§£ Future å’Œ async/await
- ç»ƒä¹ å¹¶å‘å’Œå¹¶è¡Œç¼–ç¨‹

**åŠŸèƒ½è¦æ±‚**ï¼š
- å¤šçº¿ç¨‹å¼‚æ­¥çˆ¬å–
- æ™ºèƒ½å»é‡å’Œé“¾æ¥æå–
- å°Šé‡robots.txt
- æ•°æ®å­˜å‚¨å’Œåˆ†æ

**æŠ€æœ¯è¦ç‚¹**ï¼š
```rust
use tokio::{time, sync::Semaphore};
use reqwest::Client;
use std::sync::Arc;
use std::collections::HashSet;
use tokio::sync::Mutex;

pub struct WebCrawler {
    client: Client,
    visited_urls: Arc<Mutex<HashSet<String>>>,
    semaphore: Arc<Semaphore>, // é™åˆ¶å¹¶å‘æ•°
    max_depth: u32,
}

impl WebCrawler {
    pub fn new(max_concurrent: usize, max_depth: u32) -> Self {
        WebCrawler {
            client: Client::new(),
            visited_urls: Arc::new(Mutex::new(HashSet::new())),
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
            max_depth,
        }
    }
    
    pub async fn crawl(&self, start_url: String) -> Result<CrawlResult, CrawlError> {
        let mut tasks = Vec::new();
        let initial_task = self.crawl_url(start_url, 0);
        tasks.push(tokio::spawn(initial_task));
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        let mut results = Vec::new();
        for task in tasks {
            match task.await {
                Ok(Ok(result)) => results.push(result),
                Ok(Err(e)) => eprintln!("Crawl error: {:?}", e),
                Err(e) => eprintln!("Task error: {:?}", e),
            }
        }
        
        Ok(CrawlResult::combine(results))
    }
    
    async fn crawl_url(&self, url: String, depth: u32) -> Result<PageData, CrawlError> {
        if depth > self.max_depth {
            return Err(CrawlError::MaxDepthExceeded);
        }
        
        // è·å–ä¿¡å·é‡è®¸å¯
        let _permit = self.semaphore.acquire().await
            .map_err(|_| CrawlError::SemaphoreError)?;
        
        // æ£€æŸ¥æ˜¯å¦å·²è®¿é—®
        {
            let mut visited = self.visited_urls.lock().await;
            if visited.contains(&url) {
                return Err(CrawlError::AlreadyVisited);
            }
            visited.insert(url.clone());
        }
        
        // å¼‚æ­¥HTTPè¯·æ±‚
        let response = self.client.get(&url)
            .timeout(Duration::from_secs(10))
            .send()
            .await?;
            
        if !response.status().is_success() {
            return Err(CrawlError::HttpError(response.status()));
        }
        
        let content = response.text().await?;
        let page_data = self.parse_page(url.clone(), content).await?;
        
        // é€’å½’çˆ¬å–é“¾æ¥
        let mut child_tasks = Vec::new();
        for link in &page_data.links {
            if self.should_follow_link(link) {
                let child_task = self.crawl_url(link.clone(), depth + 1);
                child_tasks.push(tokio::spawn(child_task));
            }
        }
        
        // ç­‰å¾…å­ä»»åŠ¡å®Œæˆï¼ˆå¯é€‰ï¼‰
        for task in child_tasks {
            let _ = task.await;
        }
        
        Ok(page_data)
    }
    
    async fn parse_page(&self, url: String, content: String) -> Result<PageData, CrawlError> {
        // å¼‚æ­¥è§£æHTMLï¼Œæå–é“¾æ¥å’Œæ•°æ®
        time::sleep(Duration::from_millis(100)).await; // æ¨¡æ‹Ÿè§£ææ—¶é—´
        
        // å®é™…å®ç°ä¼šä½¿ç”¨HTMLè§£æåº“
        Ok(PageData {
            url,
            title: "Sample Title".to_string(),
            links: vec!["http://example.com/page1".to_string()],
            content: content[..100.min(content.len())].to_string(),
        })
    }
}

#[derive(Debug)]
pub struct PageData {
    pub url: String,
    pub title: String,
    pub links: Vec<String>,
    pub content: String,
}

#[derive(Debug)]
pub struct CrawlResult {
    pub pages: Vec<PageData>,
    pub total_pages: usize,
    pub total_links: usize,
}
```

**æ‰©å±•æ€è·¯**ï¼š
- æ·»åŠ åˆ†å¸ƒå¼çˆ¬å–
- å®ç°æ™ºèƒ½åçˆ¬è™«ç­–ç•¥
- æ·»åŠ æ•°æ®åˆ†æåŠŸèƒ½

---

## ç»¼åˆé¡¹ç›®ï¼šRust Web åº”ç”¨

### é¡¹ç›® 11ï¼šä¸ªäººåšå®¢ç³»ç»Ÿ (ç»¼åˆé¡¹ç›®)
**å¯¹åº”ç« èŠ‚**ï¼šå…¨éƒ¨
**é¡¹ç›®æè¿°**ï¼šä½¿ç”¨æ‰€æœ‰å­¦åˆ°çš„çŸ¥è¯†æ„å»ºä¸€ä¸ªå®Œæ•´çš„Webåº”ç”¨

**å­¦ä¹ ç›®æ ‡**ï¼š
- ç»¼åˆè¿ç”¨æ‰€æœ‰ Rust çŸ¥è¯†ç‚¹
- æŒæ¡å®é™…é¡¹ç›®å¼€å‘æµç¨‹
- å­¦ä¹  Web å¼€å‘æœ€ä½³å®è·µ

**åŠŸèƒ½è¦æ±‚**ï¼š
- ç”¨æˆ·è®¤è¯å’Œæˆæƒ
- æ–‡ç« å‘å¸ƒå’Œç®¡ç†
- è¯„è®ºç³»ç»Ÿ
- æœç´¢åŠŸèƒ½
- ç®¡ç†åå°

**æŠ€æœ¯æ ˆ**ï¼š
- Webæ¡†æ¶ï¼šAxum æˆ– Actix-web
- æ•°æ®åº“ï¼šPostgreSQL + SQLx
- å‰ç«¯ï¼šHTML/CSS/JavaScript
- è®¤è¯ï¼šJWT
- éƒ¨ç½²ï¼šDocker

**é¡¹ç›®ç»“æ„**ï¼š
```
blog_system/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ migrations/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs
â”‚   â”œâ”€â”€ lib.rs
â”‚   â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ handlers/
â”‚   â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ utils/
â”‚   â””â”€â”€ tests/
â”œâ”€â”€ static/
â”œâ”€â”€ templates/
â””â”€â”€ README.md
```

---

## å­¦ä¹ è¿›åº¦å»ºè®®

### ç¬¬1-2å‘¨ï¼šåŸºç¡€è¯­æ³• (é¡¹ç›®1-2)
- æ¯å¤©1-2å°æ—¶ï¼Œé‡ç‚¹ç†è§£æ‰€æœ‰æƒæ¦‚å¿µ
- å®Œæˆè®¡ç®—å™¨å’Œæ–‡æœ¬åˆ†æå·¥å…·

### ç¬¬3-4å‘¨ï¼šæ‰€æœ‰æƒç³»ç»Ÿ (é¡¹ç›®3)
- æ·±å…¥ç»ƒä¹ å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸ
- å®Œæˆå­—ç¬¦ä¸²å¤„ç†å™¨

### ç¬¬5-6å‘¨ï¼šæ•°æ®ç»“æ„ (é¡¹ç›®4-5)
- æŒæ¡ç»“æ„ä½“å’Œæšä¸¾çš„è®¾è®¡æ¨¡å¼
- å®Œæˆå­¦ç”Ÿç®¡ç†ç³»ç»Ÿå’Œå›¾ä¹¦é¦†ç³»ç»Ÿ

### ç¬¬7-8å‘¨ï¼šæ¨¡å—åŒ– (é¡¹ç›®6)
- å­¦ä¹ å¤§å‹é¡¹ç›®çš„ç»„ç»‡æ–¹å¼
- å®Œæˆæ–‡ä»¶å¤„ç†å·¥å…·ç®±

### ç¬¬9-10å‘¨ï¼šé«˜çº§ç‰¹æ€§ (é¡¹ç›®7-8)
- æ·±å…¥ç†è§£æ³›å‹å’Œ trait
- å®Œæˆæ•°æ®å®¹å™¨åº“å’Œç¼“å­˜ç³»ç»Ÿ

### ç¬¬11-12å‘¨ï¼šç³»ç»Ÿç¼–ç¨‹ (é¡¹ç›®9-10)
- æŒæ¡å¼‚æ­¥ç¼–ç¨‹å’Œç³»ç»Ÿäº¤äº’
- å®Œæˆç›‘æ§å·¥å…·å’Œçˆ¬è™«

### ç¬¬13-16å‘¨ï¼šç»¼åˆé¡¹ç›® (é¡¹ç›®11)
- ç»¼åˆè¿ç”¨æ‰€æœ‰çŸ¥è¯†
- å®Œæˆå®Œæ•´çš„Webåº”ç”¨

---

## é¡¹ç›®è¯„ä¼°æ ‡å‡†

### ä»£ç è´¨é‡ (40%)
- ä»£ç ç»“æ„æ¸…æ™°ï¼Œæ¨¡å—åŒ–è‰¯å¥½
- éµå¾ª Rust ç¼–ç¨‹æƒ¯ä¾‹
- é€‚å½“çš„é”™è¯¯å¤„ç†
- å……åˆ†çš„æ–‡æ¡£å’Œæ³¨é‡Š

### åŠŸèƒ½å®Œæ•´æ€§ (30%)
- å®ç°æ‰€æœ‰è¦æ±‚çš„åŸºç¡€åŠŸèƒ½
- ç¨‹åºè¿è¡Œç¨³å®šï¼Œæ— å´©æºƒ
- è¾¹ç•Œæ¡ä»¶å¤„ç†å¾—å½“

### åˆ›æ–°å’Œæ‰©å±• (20%)
- å®ç°é¢å¤–çš„åŠŸèƒ½ç‰¹æ€§
- ä¼˜åŒ–æ€§èƒ½æˆ–ç”¨æˆ·ä½“éªŒ
- ä½¿ç”¨æ–°çš„åº“æˆ–æŠ€æœ¯

### å­¦ä¹ åæ€ (10%)
- èƒ½å¤Ÿè§£é‡Šå®ç°æ€è·¯
- è¯†åˆ«å’Œè§£å†³é‡åˆ°çš„é—®é¢˜
- æ€»ç»“å­¦åˆ°çš„çŸ¥è¯†ç‚¹

---

## èµ„æºå’Œå·¥å…·æ¨è

### å¼€å‘å·¥å…·
- **IDE**: VS Code + rust-analyzer
- **ç‰ˆæœ¬æ§åˆ¶**: Git
- **æ–‡æ¡£**: cargo doc
- **æµ‹è¯•**: cargo test
- **åŸºå‡†æµ‹è¯•**: criterion

### æ¨ècrates
- **CLIå·¥å…·**: clap, structopt
- **åºåˆ—åŒ–**: serde
- **HTTPå®¢æˆ·ç«¯**: reqwest
- **Webæ¡†æ¶**: axum, actix-web
- **æ•°æ®åº“**: sqlx, diesel
- **å¼‚æ­¥è¿è¡Œæ—¶**: tokio
- **æµ‹è¯•**: proptest, mockall

### å­¦ä¹ èµ„æº
- [The Rust Book](https://doc.rust-lang.org/book/)
- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
- [Rustlings](https://github.com/rust-lang/rustlings)
- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)

---

## æ€»ç»“

è¿™ä¸ªå®æ“é¡¹ç›®è§„åˆ’æ—¨åœ¨é€šè¿‡å¾ªåºæ¸è¿›çš„å®è·µé¡¹ç›®ï¼Œå¸®åŠ©å­¦ä¹ è€…çœŸæ­£æŒæ¡ Rust ç¼–ç¨‹è¯­è¨€ã€‚æ¯ä¸ªé¡¹ç›®éƒ½ç»è¿‡ç²¾å¿ƒè®¾è®¡ï¼Œç¡®ä¿ç†è®ºå­¦ä¹ ä¸å®é™…åº”ç”¨ç›¸ç»“åˆï¼Œè®©å­¦ä¹ è€…åœ¨åŠ¨æ‰‹å®è·µä¸­æ·±å…¥ç†è§£ Rust çš„æ ¸å¿ƒæ¦‚å¿µå’Œæœ€ä½³å®è·µã€‚

è®°ä½ï¼Œå­¦ä¹ ç¼–ç¨‹æœ€é‡è¦çš„æ˜¯å¤šåŠ¨æ‰‹ã€å¤šæ€è€ƒã€å¤šæ€»ç»“ã€‚æ¯å®Œæˆä¸€ä¸ªé¡¹ç›®ï¼Œéƒ½è¦å›é¡¾æ‰€å­¦çŸ¥è¯†ï¼Œæ€è€ƒå¯ä»¥æ”¹è¿›çš„åœ°æ–¹ï¼Œè¿™æ ·æ‰èƒ½çœŸæ­£æé«˜ç¼–ç¨‹æ°´å¹³ã€‚

ç¥ä½ åœ¨ Rust å­¦ä¹ ä¹‹è·¯ä¸Šå–å¾—æˆåŠŸï¼ğŸ¦€
