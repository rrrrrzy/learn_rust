# Rust 学习实操项目规划

## 项目设计理念

本实操项目规划基于**渐进式学习**和**实践驱动**的教学理念，每个项目都精心设计来巩固特定的知识点，让学习者通过动手实践真正掌握 Rust 编程技能。

### 设计原则
1. **知识点覆盖**：每个项目都对应特定的教程章节，确保理论与实践结合
2. **难度递进**：从简单的控制台程序到复杂的系统应用
3. **实用性导向**：项目具有实际应用价值，不是简单的练习题
4. **可扩展性**：每个项目都可以进一步扩展和改进

---

## 阶段一：基础语法巩固 (第 1-4 章)
*学习内容：变量、数据类型、函数、控制流*

### 项目 1：智能计算器
**对应章节**：01-02 (变量和数据类型)
**项目描述**：创建一个支持基本四则运算的计算器

**学习目标**：
- 掌握变量声明和可变性
- 理解不同数值类型的使用场景
- 练习类型转换和类型安全

**功能要求**：
- 支持整数和浮点数运算
- 处理除零错误
- 支持连续计算（结果作为下次计算的输入）
- 使用不同的数值类型展示类型系统

**技术要点**：
```rust
// 示例核心代码结构
fn main() {
    let mut result: f64 = 0.0;
    let mut continue_calculation = true;
    
    while continue_calculation {
        // 获取用户输入
        // 解析操作符和操作数
        // 执行计算并更新结果
        // 处理错误情况
    }
}
```

**扩展思路**：
- 添加科学计算功能（平方根、幂运算）
- 支持括号运算
- 添加历史记录功能

---

### 项目 2：文本分析工具
**对应章节**：03-04 (函数和控制流)
**项目描述**：分析文本文件或用户输入的统计信息

**学习目标**：
- 练习函数的定义和调用
- 掌握控制流结构（if/else、loop、match）
- 理解作用域和所有权基础概念

**功能要求**：
- 统计字符数、单词数、行数
- 分析字符频率
- 查找最长/最短单词
- 使用不同的控制流结构

**技术要点**：
```rust
fn analyze_text(text: &str) -> TextStats {
    let mut stats = TextStats::new();
    
    for line in text.lines() {
        stats.line_count += 1;
        
        for word in line.split_whitespace() {
            stats.word_count += 1;
            
            for ch in word.chars() {
                stats.char_count += 1;
                // 使用 match 处理不同字符类型
            }
        }
    }
    
    stats
}
```

**扩展思路**：
- 支持多种文件格式
- 添加情感分析
- 实现关键词高频统计

---

## 阶段二：所有权系统掌握 (第 5-6 章)
*学习内容：所有权、借用、引用、切片*

### 项目 3：内存安全的字符串处理器
**对应章节**：05-06 (所有权和引用)
**项目描述**：实现一个强调内存安全的字符串处理库

**学习目标**：
- 深入理解所有权转移规则
- 掌握借用和引用的使用
- 练习切片操作

**功能要求**：
- 字符串反转、大小写转换
- 单词提取和替换
- 安全的字符串切片操作
- 字符串拼接和分割

**技术要点**：
```rust
// 演示所有权转移
fn process_string(s: String) -> String {
    // s 的所有权被转移到这里
    s.to_uppercase()
} // s 在这里被释放

// 演示借用
fn analyze_string(s: &str) -> (usize, usize) {
    (s.len(), s.chars().count())
}

// 演示可变借用
fn modify_string(s: &mut String) {
    s.push_str(" - processed");
}
```

**扩展思路**：
- 实现自定义字符串类型
- 添加 Unicode 处理
- 实现字符串池优化

---

## 阶段三：数据结构设计 (第 7-9 章)
*学习内容：结构体、枚举、集合*

### 项目 4：学生成绩管理系统
**对应章节**：07-08 (结构体和枚举)
**项目描述**：设计一个完整的学生信息和成绩管理系统

**学习目标**：
- 掌握结构体的定义和方法实现
- 理解枚举的强大功能和模式匹配
- 练习复杂数据结构的设计

**功能要求**：
- 学生信息管理（增删改查）
- 多科目成绩记录
- 成绩统计和排名
- 不同成绩等级的枚举处理

**技术要点**：
```rust
#[derive(Debug, Clone)]
struct Student {
    id: u32,
    name: String,
    grade: Grade,
    subjects: HashMap<Subject, Score>,
}

#[derive(Debug, Clone)]
enum Grade {
    Freshman,
    Sophomore,
    Junior,
    Senior,
}

#[derive(Debug, Clone)]
enum ScoreLevel {
    Excellent(f64),    // 90-100
    Good(f64),         // 80-89
    Average(f64),      // 70-79
    Poor(f64),         // 60-69
    Fail(f64),         // 0-59
}

impl Student {
    fn calculate_gpa(&self) -> f64 {
        // 实现 GPA 计算
    }
    
    fn get_score_level(&self, subject: &Subject) -> Option<ScoreLevel> {
        // 使用模式匹配返回成绩等级
    }
}
```

**扩展思路**：
- 添加数据持久化
- 实现成绩趋势分析
- 添加图形化界面

---

### 项目 5：图书馆管理系统
**对应章节**：09 (集合类型)
**项目描述**：使用各种集合类型构建图书馆管理系统

**学习目标**：
- 掌握 Vec、HashMap、HashSet 的使用
- 理解不同集合类型的适用场景
- 练习复杂数据查询和操作

**功能要求**：
- 图书信息管理
- 借阅记录追踪
- 读者信息管理
- 图书搜索和推荐

**技术要点**：
```rust
use std::collections::{HashMap, HashSet, VecDeque};

struct Library {
    books: HashMap<String, Book>,           // ISBN -> Book
    readers: HashMap<u32, Reader>,          // ID -> Reader
    borrowed_books: HashMap<String, u32>,   // ISBN -> Reader ID
    waiting_queue: VecDeque<(String, u32)>, // (ISBN, Reader ID)
    categories: HashSet<String>,            // 图书分类
}

impl Library {
    fn search_books(&self, keyword: &str) -> Vec<&Book> {
        self.books.values()
            .filter(|book| {
                book.title.contains(keyword) || 
                book.author.contains(keyword) ||
                book.isbn.contains(keyword)
            })
            .collect()
    }
    
    fn recommend_books(&self, reader_id: u32) -> Vec<&Book> {
        // 基于借阅历史的推荐算法
    }
}
```

**扩展思路**：
- 实现复杂的搜索算法
- 添加图书预约系统
- 实现数据统计和报表

---

## 阶段四：模块化开发 (第 10-11 章)
*学习内容：模块系统、错误处理*

### 项目 6：文件处理工具箱
**对应章节**：10-11 (模块系统和错误处理)
**项目描述**：创建一个模块化的文件处理工具集

**学习目标**：
- 掌握模块系统的设计和使用
- 理解错误处理的最佳实践
- 练习 Result 和 Option 的使用

**项目结构**：
```
file_tools/
├── src/
│   ├── main.rs
│   ├── lib.rs
│   ├── file_ops/
│   │   ├── mod.rs
│   │   ├── reader.rs
│   │   ├── writer.rs
│   │   └── analyzer.rs
│   ├── crypto/
│   │   ├── mod.rs
│   │   ├── hash.rs
│   │   └── encrypt.rs
│   └── utils/
│       ├── mod.rs
│       ├── path.rs
│       └── error.rs
└── Cargo.toml
```

**功能要求**：
- 文件读写操作
- 文件加密解密
- 文件完整性验证
- 批量文件处理

**技术要点**：
```rust
// src/utils/error.rs
#[derive(Debug)]
pub enum FileToolError {
    IoError(std::io::Error),
    PermissionDenied,
    FileNotFound(String),
    InvalidFormat(String),
}

impl From<std::io::Error> for FileToolError {
    fn from(error: std::io::Error) -> Self {
        FileToolError::IoError(error)
    }
}

// src/file_ops/reader.rs
pub fn read_file_safe(path: &Path) -> Result<String, FileToolError> {
    if !path.exists() {
        return Err(FileToolError::FileNotFound(
            path.display().to_string()
        ));
    }
    
    std::fs::read_to_string(path)
        .map_err(FileToolError::from)
}
```

**扩展思路**：
- 添加网络文件操作
- 实现文件同步功能
- 添加GUI界面

---

## 阶段五：高级特性应用 (第 12-14 章)
*学习内容：泛型、Trait、生命周期*

### 项目 7：通用数据容器库
**对应章节**：12-13 (泛型和Trait)
**项目描述**：设计一个高度可复用的数据容器库

**学习目标**：
- 掌握泛型的高级应用
- 理解 Trait 的设计模式
- 练习 Trait 边界和关联类型

**功能要求**：
- 实现多种容器类型（栈、队列、树）
- 支持泛型元素类型
- 提供统一的容器接口
- 实现迭代器模式

**技术要点**：
```rust
// 定义容器 trait
pub trait Container<T> {
    fn new() -> Self;
    fn len(&self) -> usize;
    fn is_empty(&self) -> bool;
    fn clear(&mut self);
}

pub trait Stack<T>: Container<T> {
    fn push(&mut self, item: T);
    fn pop(&mut self) -> Option<T>;
    fn peek(&self) -> Option<&T>;
}

pub trait Queue<T>: Container<T> {
    fn enqueue(&mut self, item: T);
    fn dequeue(&mut self) -> Option<T>;
    fn front(&self) -> Option<&T>;
}

// 实现通用栈
pub struct VecStack<T> {
    items: Vec<T>,
}

impl<T> Container<T> for VecStack<T> {
    fn new() -> Self {
        VecStack { items: Vec::new() }
    }
    
    fn len(&self) -> usize {
        self.items.len()
    }
    
    fn is_empty(&self) -> bool {
        self.items.is_empty()
    }
    
    fn clear(&mut self) {
        self.items.clear()
    }
}

impl<T> Stack<T> for VecStack<T> {
    fn push(&mut self, item: T) {
        self.items.push(item);
    }
    
    fn pop(&mut self) -> Option<T> {
        self.items.pop()
    }
    
    fn peek(&self) -> Option<&T> {
        self.items.last()
    }
}
```

**扩展思路**：
- 实现线程安全版本
- 添加性能基准测试
- 实现自定义迭代器

---

### 项目 8：内存安全的缓存系统
**对应章节**：14 (生命周期)
**项目描述**：实现一个强调内存安全的缓存系统

**学习目标**：
- 深入理解生命周期概念
- 掌握生命周期注解的使用
- 练习复杂的引用关系管理

**功能要求**：
- LRU 缓存实现
- 过期时间管理
- 内存使用限制
- 线程安全支持

**技术要点**：
```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

pub struct Cache<'a, K, V> 
where 
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    data: HashMap<K, CacheEntry<'a, V>>,
    max_size: usize,
    default_ttl: Duration,
}

struct CacheEntry<'a, V> {
    value: V,
    created_at: Instant,
    ttl: Duration,
    access_count: u64,
    references: Vec<&'a V>, // 演示复杂生命周期关系
}

impl<'a, K, V> Cache<'a, K, V> 
where 
    K: Eq + std::hash::Hash + Clone,
    V: Clone,
{
    pub fn new(max_size: usize, default_ttl: Duration) -> Self {
        Cache {
            data: HashMap::new(),
            max_size,
            default_ttl,
        }
    }
    
    pub fn get(&'a mut self, key: &K) -> Option<&'a V> {
        if let Some(entry) = self.data.get_mut(key) {
            if entry.is_expired() {
                self.data.remove(key);
                None
            } else {
                entry.access_count += 1;
                Some(&entry.value)
            }
        } else {
            None
        }
    }
    
    pub fn insert(&mut self, key: K, value: V) -> Result<(), CacheError> {
        if self.data.len() >= self.max_size {
            self.evict_lru()?;
        }
        
        let entry = CacheEntry {
            value,
            created_at: Instant::now(),
            ttl: self.default_ttl,
            access_count: 1,
            references: Vec::new(),
        };
        
        self.data.insert(key, entry);
        Ok(())
    }
}
```

**扩展思路**：
- 实现分布式缓存
- 添加缓存预热功能
- 实现缓存统计和监控

---

## 阶段六：系统编程应用 (第 15-16 章)
*学习内容：标准库、异步编程*

### 项目 9：系统监控工具
**对应章节**：15 (标准库)
**项目描述**：开发一个跨平台的系统监控工具

**学习目标**：
- 掌握标准库的高级功能
- 学习系统编程技巧
- 练习宏编程

**功能要求**：
- CPU、内存、磁盘使用率监控
- 进程管理和监控
- 网络连接状态
- 系统日志分析

**技术要点**：
```rust
use std::process::Command;
use std::fs;
use std::time::{Duration, SystemTime};
use std::collections::VecDeque;

// 自定义宏用于简化系统信息获取
macro_rules! system_info {
    ($cmd:expr) => {
        Command::new("sh")
            .arg("-c")
            .arg($cmd)
            .output()
            .map(|output| String::from_utf8_lossy(&output.stdout).to_string())
            .unwrap_or_else(|_| "Unknown".to_string())
    };
}

#[derive(Debug, Clone)]
pub struct SystemSnapshot {
    timestamp: SystemTime,
    cpu_usage: f64,
    memory_usage: MemoryInfo,
    disk_usage: Vec<DiskInfo>,
    network_info: NetworkInfo,
}

impl SystemSnapshot {
    pub fn capture() -> Result<Self, SystemError> {
        Ok(SystemSnapshot {
            timestamp: SystemTime::now(),
            cpu_usage: Self::get_cpu_usage()?,
            memory_usage: Self::get_memory_info()?,
            disk_usage: Self::get_disk_info()?,
            network_info: Self::get_network_info()?,
        })
    }
    
    fn get_cpu_usage() -> Result<f64, SystemError> {
        // 使用 /proc/stat 或系统命令获取CPU使用率
        let output = system_info!("top -bn1 | grep 'Cpu(s)' | awk '{print $2}' | cut -d'%' -f1");
        output.trim().parse()
            .map_err(|_| SystemError::ParseError("CPU usage".to_string()))
    }
}

pub struct Monitor {
    snapshots: VecDeque<SystemSnapshot>,
    max_history: usize,
}

impl Monitor {
    pub fn new(max_history: usize) -> Self {
        Monitor {
            snapshots: VecDeque::new(),
            max_history,
        }
    }
    
    pub fn start_monitoring(&mut self, interval: Duration) -> Result<(), SystemError> {
        loop {
            let snapshot = SystemSnapshot::capture()?;
            
            if self.snapshots.len() >= self.max_history {
                self.snapshots.pop_front();
            }
            
            self.snapshots.push_back(snapshot);
            
            std::thread::sleep(interval);
        }
    }
}
```

**扩展思路**：
- 添加报警功能
- 实现Web界面
- 支持远程监控

---

### 项目 10：异步Web爬虫
**对应章节**：16 (异步编程)
**项目描述**：构建一个高性能的异步Web爬虫系统

**学习目标**：
- 掌握异步编程模型
- 理解 Future 和 async/await
- 练习并发和并行编程

**功能要求**：
- 多线程异步爬取
- 智能去重和链接提取
- 尊重robots.txt
- 数据存储和分析

**技术要点**：
```rust
use tokio::{time, sync::Semaphore};
use reqwest::Client;
use std::sync::Arc;
use std::collections::HashSet;
use tokio::sync::Mutex;

pub struct WebCrawler {
    client: Client,
    visited_urls: Arc<Mutex<HashSet<String>>>,
    semaphore: Arc<Semaphore>, // 限制并发数
    max_depth: u32,
}

impl WebCrawler {
    pub fn new(max_concurrent: usize, max_depth: u32) -> Self {
        WebCrawler {
            client: Client::new(),
            visited_urls: Arc::new(Mutex::new(HashSet::new())),
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
            max_depth,
        }
    }
    
    pub async fn crawl(&self, start_url: String) -> Result<CrawlResult, CrawlError> {
        let mut tasks = Vec::new();
        let initial_task = self.crawl_url(start_url, 0);
        tasks.push(tokio::spawn(initial_task));
        
        // 等待所有任务完成
        let mut results = Vec::new();
        for task in tasks {
            match task.await {
                Ok(Ok(result)) => results.push(result),
                Ok(Err(e)) => eprintln!("Crawl error: {:?}", e),
                Err(e) => eprintln!("Task error: {:?}", e),
            }
        }
        
        Ok(CrawlResult::combine(results))
    }
    
    async fn crawl_url(&self, url: String, depth: u32) -> Result<PageData, CrawlError> {
        if depth > self.max_depth {
            return Err(CrawlError::MaxDepthExceeded);
        }
        
        // 获取信号量许可
        let _permit = self.semaphore.acquire().await
            .map_err(|_| CrawlError::SemaphoreError)?;
        
        // 检查是否已访问
        {
            let mut visited = self.visited_urls.lock().await;
            if visited.contains(&url) {
                return Err(CrawlError::AlreadyVisited);
            }
            visited.insert(url.clone());
        }
        
        // 异步HTTP请求
        let response = self.client.get(&url)
            .timeout(Duration::from_secs(10))
            .send()
            .await?;
            
        if !response.status().is_success() {
            return Err(CrawlError::HttpError(response.status()));
        }
        
        let content = response.text().await?;
        let page_data = self.parse_page(url.clone(), content).await?;
        
        // 递归爬取链接
        let mut child_tasks = Vec::new();
        for link in &page_data.links {
            if self.should_follow_link(link) {
                let child_task = self.crawl_url(link.clone(), depth + 1);
                child_tasks.push(tokio::spawn(child_task));
            }
        }
        
        // 等待子任务完成（可选）
        for task in child_tasks {
            let _ = task.await;
        }
        
        Ok(page_data)
    }
    
    async fn parse_page(&self, url: String, content: String) -> Result<PageData, CrawlError> {
        // 异步解析HTML，提取链接和数据
        time::sleep(Duration::from_millis(100)).await; // 模拟解析时间
        
        // 实际实现会使用HTML解析库
        Ok(PageData {
            url,
            title: "Sample Title".to_string(),
            links: vec!["http://example.com/page1".to_string()],
            content: content[..100.min(content.len())].to_string(),
        })
    }
}

#[derive(Debug)]
pub struct PageData {
    pub url: String,
    pub title: String,
    pub links: Vec<String>,
    pub content: String,
}

#[derive(Debug)]
pub struct CrawlResult {
    pub pages: Vec<PageData>,
    pub total_pages: usize,
    pub total_links: usize,
}
```

**扩展思路**：
- 添加分布式爬取
- 实现智能反爬虫策略
- 添加数据分析功能

---

## 综合项目：Rust Web 应用

### 项目 11：个人博客系统 (综合项目)
**对应章节**：全部
**项目描述**：使用所有学到的知识构建一个完整的Web应用

**学习目标**：
- 综合运用所有 Rust 知识点
- 掌握实际项目开发流程
- 学习 Web 开发最佳实践

**功能要求**：
- 用户认证和授权
- 文章发布和管理
- 评论系统
- 搜索功能
- 管理后台

**技术栈**：
- Web框架：Axum 或 Actix-web
- 数据库：PostgreSQL + SQLx
- 前端：HTML/CSS/JavaScript
- 认证：JWT
- 部署：Docker

**项目结构**：
```
blog_system/
├── Cargo.toml
├── Dockerfile
├── migrations/
├── src/
│   ├── main.rs
│   ├── lib.rs
│   ├── config/
│   ├── models/
│   ├── handlers/
│   ├── services/
│   ├── utils/
│   └── tests/
├── static/
├── templates/
└── README.md
```

---

## 学习进度建议

### 第1-2周：基础语法 (项目1-2)
- 每天1-2小时，重点理解所有权概念
- 完成计算器和文本分析工具

### 第3-4周：所有权系统 (项目3)
- 深入练习借用和生命周期
- 完成字符串处理器

### 第5-6周：数据结构 (项目4-5)
- 掌握结构体和枚举的设计模式
- 完成学生管理系统和图书馆系统

### 第7-8周：模块化 (项目6)
- 学习大型项目的组织方式
- 完成文件处理工具箱

### 第9-10周：高级特性 (项目7-8)
- 深入理解泛型和 trait
- 完成数据容器库和缓存系统

### 第11-12周：系统编程 (项目9-10)
- 掌握异步编程和系统交互
- 完成监控工具和爬虫

### 第13-16周：综合项目 (项目11)
- 综合运用所有知识
- 完成完整的Web应用

---

## 项目评估标准

### 代码质量 (40%)
- 代码结构清晰，模块化良好
- 遵循 Rust 编程惯例
- 适当的错误处理
- 充分的文档和注释

### 功能完整性 (30%)
- 实现所有要求的基础功能
- 程序运行稳定，无崩溃
- 边界条件处理得当

### 创新和扩展 (20%)
- 实现额外的功能特性
- 优化性能或用户体验
- 使用新的库或技术

### 学习反思 (10%)
- 能够解释实现思路
- 识别和解决遇到的问题
- 总结学到的知识点

---

## 资源和工具推荐

### 开发工具
- **IDE**: VS Code + rust-analyzer
- **版本控制**: Git
- **文档**: cargo doc
- **测试**: cargo test
- **基准测试**: criterion

### 推荐crates
- **CLI工具**: clap, structopt
- **序列化**: serde
- **HTTP客户端**: reqwest
- **Web框架**: axum, actix-web
- **数据库**: sqlx, diesel
- **异步运行时**: tokio
- **测试**: proptest, mockall

### 学习资源
- [The Rust Book](https://doc.rust-lang.org/book/)
- [Rust by Example](https://doc.rust-lang.org/rust-by-example/)
- [Rustlings](https://github.com/rust-lang/rustlings)
- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)

---

## 总结

这个实操项目规划旨在通过循序渐进的实践项目，帮助学习者真正掌握 Rust 编程语言。每个项目都经过精心设计，确保理论学习与实际应用相结合，让学习者在动手实践中深入理解 Rust 的核心概念和最佳实践。

记住，学习编程最重要的是多动手、多思考、多总结。每完成一个项目，都要回顾所学知识，思考可以改进的地方，这样才能真正提高编程水平。

祝你在 Rust 学习之路上取得成功！🦀
